@inject ToastService ToastService
@inject IJSRuntime JS
@implements IDisposable

<div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
    @foreach (var toast in toasts)
    {
        <div @ref="toast.Element" class="toast align-items-center text-white bg-@GetBgClass(toast.Level) border-0 mb-2"
             role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    <i class="@GetIcon(toast.Level) me-2"></i>
                    <strong>@toast.Title:</strong> @toast.Message
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto"
                        data-bs-dismiss="toast" aria-label="Close"
                        @onclick="() => Remove(toast)"></button>
            </div>
        </div>
    }
</div>

@code {
    private readonly List<ToastMessage> toasts = new();
    private bool _disposed;

    protected override void OnInitialized()
    {
        ToastService.OnShow += ShowToast;
    }

    private async void ShowToast(string title, string message, ToastLevel level)
    {
        if (_disposed) return;
        
        var toast = new ToastMessage { Title = title, Message = message, Level = level };
        toasts.Add(toast);
        StateHasChanged();

        // Wait for render to ensure Element is populated
        await Task.Yield();
        
        if (toast.Element.Context != null)
        {
            await JS.InvokeVoidAsync("bootstrapUtils.showToast", toast.Element);
        }

        // Auto-remove from list after delay (Bootstrap default is 5000ms)
        _ = Task.Delay(6000).ContinueWith(_ => 
        { 
            if (!_disposed)
            {
                InvokeAsync(() => Remove(toast)); 
            }
        });
    }

    private void Remove(ToastMessage toast)
    {
        if (_disposed) return;
        toasts.Remove(toast);
        StateHasChanged();
    }

    public void Dispose()
    {
        _disposed = true;
        ToastService.OnShow -= ShowToast;
    }

    private string GetBgClass(ToastLevel level)
    {
        return level switch
        {
            ToastLevel.Success => "success",
            ToastLevel.Error => "danger",
            ToastLevel.Warning => "warning",
            ToastLevel.Info => "info",
            _ => "secondary"
        };
    }

    private string GetIcon(ToastLevel level)
    {
        return level switch
        {
            ToastLevel.Success => "bi bi-check-circle-fill",
            ToastLevel.Error => "bi bi-exclamation-octagon-fill",
            ToastLevel.Warning => "bi bi-exclamation-triangle-fill",
            ToastLevel.Info => "bi bi-info-circle-fill",
            _ => "bi bi-bell-fill"
        };
    }

    private class ToastMessage
    {
        public string Title { get; set; } = "";
        public string Message { get; set; } = "";
        public ToastLevel Level { get; set; }
        public ElementReference Element { get; set; }
    }

}
